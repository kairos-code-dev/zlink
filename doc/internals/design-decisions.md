[English](design-decisions.md) | [한국어](design-decisions.ko.md)

# Design Decision Records

This document records the rationale and alternative analyses for key design decisions in zlink.

---

## 1. Routing ID Policy

### 1.1 Socket Own Routing ID: 16B UUID

**Decision**: Unify all sockets' auto-generated own routing_id to 16B UUID (binary).

**Rationale**:
- The existing 5B `[0x00][uint32]` format had collision potential across processes
- 16B UUID guarantees global uniqueness across nodes/processes
- Provides sufficient entropy for socket identification in monitoring/debugging

**Alternatives considered**:
- 4B uint32 unified -- discarded due to collision potential
- 5B unified -- discarded due to insufficient uniqueness compared to 16B UUID

### 1.2 STREAM Peer/Client Routing ID: 4B uint32

**Decision**: STREAM per-connection peer routing_id is 4B uint32.

**Rationale**:
- The routing_id field inside msg_t is already uint32_t
- uint32 range is sufficient for connection counts
- Clear separation of purpose between own routing_id (identification) and peer routing_id (routing)

### 1.3 String Alias Retention

**Decision**: ZLINK_ROUTING_ID and ZLINK_CONNECT_ROUTING_ID retain variable-length strings.

**Rationale**:
- String alias-based debugging/logging patterns are widely used with ROUTER
- Per-connection alias designation capability is needed
- routing_id length is not fixed

### 1.4 Default Routing ID Generation Location

**Decision**: Generated in core/src/sockets/socket_base.cpp (core, not service layer).

**Rationale**:
- Core already has socket_id-based auto-generation behavior
- Service utility (routing_id_utils.hpp) is used only for override purposes
- Prevents layer violation (no services → core dependency inversion)

---

## 2. Monitoring Design

### 2.1 Polling Approach Selection

**Decision**: Monitoring provides only the polling (PAIR socket) approach.

**Rationale**:
- Callback approach risks deadlock when called from the I/O thread
- Polling is safely processed in the user thread
- Can combine multi-socket monitoring via zlink_poll

### 2.2 CONNECTION_READY Event

**Decision**: Replace HANDSHAKE_SUCCEEDED with CONNECTION_READY.

**Rationale**:
- CONNECTED/ACCEPTED are transport-level events that cause confusion
- Clearly communicates the "actual send/receive ready" point to users
- Unifies meaning: handshake complete = connection ready

### 2.3 DISCONNECTED Reason Code

**Decision**: Add reason codes (0~5) to the DISCONNECTED event.

**Rationale**:
- Need to distinguish intentional shutdown (LOCAL) from unintentional shutdown (TRANSPORT_ERROR)
- Identifying disconnect causes is essential for operational debugging

### 2.4 Single Event Format

**Decision**: Use a single format instead of Version 1/2.

**Rationale**:
- No backward compatibility needed (no compatibility policy)
- Simplifies implementation/usage by eliminating format branching logic

---

## 3. Deprecated Features

### 3.1 Thread-safe Socket (#02)

**Deprecation reason**:
- Insufficient practical benefit relative to the complexity of Asio Strand serialization
- Single-thread-per-socket access pattern is sufficient in practice
- Increased internal complexity makes debugging difficult

### 3.2 Request/Reply API (#03)

**Deprecation reason**:
- Gateway API provides the same functionality more completely
- Maintaining a separate API creates duplicate code/concepts
- Gateway's request_id-based mapping replaces the REQ/REP pattern

### 3.3 Metrics API (#07)

**Deprecation reason**:
- Performance overhead of socket-level statistics collection
- More efficient for applications to collect only the metrics they need
- Integration with external monitoring systems (Prometheus, etc.) is more appropriate

---

## 4. Service Discovery Design

### 4.1 Discovery/Gateway Separation

**Decision**: Separate Discovery (service finding) and Gateway (message routing) into distinct components.

**Rationale**:
- Separation of concerns: "where is it" and "how to send" are independent
- Discovery can be used standalone (service list queries)
- Multiple Gateways can be created from the same Discovery

### 4.2 ROUTER/ROUTER Pattern

**Decision**: Use ROUTER/ROUTER for Gateway <-> Receiver communication.

**Rationale**:
- Enables target designation via routing_id
- Ensures scalability for multiple Gateways/Receivers
- Bidirectional socket handles both request sending and response receiving

### 4.3 request_id-Based Mapping

**Decision**: Use uint64_t request_id for request-response mapping.

**Rationale**:
- Maps responses regardless of order when sending simultaneous requests to multiple Receivers
- Auto-generated by Gateway to minimize management burden

---

## 5. SPOT Design

### 5.1 PUB/SUB-Based Mesh

**Decision**: SPOT cluster is composed of a PUB/SUB mesh.

**Rationale**:
- PUB/SUB is natural for topic-based fanout
- Subscription filtering is more efficient than ROUTER-based approaches
- Enables automatic mesh formation via Discovery

### 5.2 No Re-publishing Policy

**Decision**: Remotely received messages are distributed locally only, not re-published.

**Rationale**:
- Re-publishing causes message loops/duplicates
- Full-mesh connectivity guarantees 1-hop delivery
- Saves network bandwidth

---

## 6. ZMQ -> ZLINK Naming Transition

**Decision**: Fully transition zmq/ZMQ/ZeroMQ naming to zlink/ZLINK. No compatibility provided.

**Rationale**:
- Establish clear identity as an independent project
- Since ZMTP is incompatible, maintaining API compatibility is meaningless
- Full replacement eliminates confusion
